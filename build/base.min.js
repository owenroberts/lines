class Drawing{constructor(t){if(this.points=[],t)for(let s=0;s<t.length;s++)this.add(t[s]);this.offset=new Cool.Vector,this.lastDrawCount=0}add(t){"end"==t||0==t?this.points.push("end"):Array.isArray(t)?this.points.push({x:t[0],y:t[1],off:[]}):this.points.push({...t,off:[]})}pop(){this.points.pop()}get(t){return t<0?this.points[this.points.length-t]:this.points[t]}get length(){return this.points.length}get needsUpdate(){return this.lastDrawCount<drawCount&&(this.lastDrawCount=drawCount,!0)}update(t,s,r,e,i){this.offset=(new Cool.Vector).random(0,r);let h=(new Cool.Vector).random(e);for(let e=0;e<this.points.length;e++)if("end"!=this.points[e]){this.points[e].off=[];for(let n=0;n<t;n++){if(r>0&&(0==n||i)){this.offset.add(h);for(const t in h)(this.offset[t]>=r||this.offset[t]<=-r)&&(h[t]*=-1)}this.points[e].off.push({x:Cool.random(-s,s)+this.offset.x,y:Cool.random(-s,s)+this.offset.y})}}}}class LinesAnimation{constructor(t,s,r){this.ctx=t,this.loaded=!1,this.isPlaying=!1,this.drawings=[],this.layers=[],this.currentFrame=0,this.dps=s||30,this.fps=5,this.drawsPerFrame=Math.round(this.dps/this.fps),this.drawCount=0,this.mixedColors=r||!0,this.rndr={off:{x:0,y:0},speed:{x:0,y:0}},this._state="default",this.states={default:{start:0,end:0}},this.over={},this.override=!0}set fps(t){this._fps=+t,this.drawsPerFrame=Math.round(this.dps/this.fps),this.drawCount=0}get fps(){return this._fps}set dps(t){this._dps=+t,this.drawsPerFrame=Math.round(this.dps/this.fps),this.drawCount=0}get dps(){return this._dps}set frame(t){this.currentFrame=this.currentFrameCounter=+t,this.states.default&&this.states.default.end!=this.endFrame&&(this.states.default.end=this.endFrame)}get frame4(){return+this.currentFrameCounter.toFixed(4)}get endFrame(){return this.layers.length>0?Math.max.apply(Math,this.layers.map(t=>t.f.e)):0}set state(t){this._state!=t&&this.states[t]&&(this._state=t,this.state&&(this.frame=this.state.start))}get state(){return this.states[this._state]}get stateName(){return this._state}overrideProperty(t,s){this.over[t]=s,this.override=!0}cancelOverride(){this.over={},this.override=!1}update(){this.isPlaying&&(this.drawCount==this.drawsPerFrame&&(this.currentFrame>=this.state.end?(this.currentFrame=this.state.start,this.onPlayedState&&this.onPlayedState()):this.currentFrame++,this.drawCount=0),this.drawCount++,this.onUpdate&&this.onUpdate())}draw(t,s,r){this.mixedColors||this.ctx.beginPath();const e=this.layers.filter(t=>this.currentFrame>=t.f.s&&this.currentFrame<=t.f.e).sort((t,s)=>t.order?t.order>s.order?1:-1:1);for(let i=0;i<e.length;i++){const h=e[i],n=this.drawings[h.d];if(this.currentFrame>=h.f.s&&this.currentFrame<=h.f.e){this.rndr.s=0,this.rndr.e=n.length;for(const t in h)this.rndr[t]=h[t];if(t&&(this.rndr.x+=t),s&&(this.rndr.y+=s),h.t)for(let t=0;t<h.t.length;t++){const s=h.t[t];s.sf<=this.currentFrame&&s.ef>=this.currentFrame&&(this.rndr[s.prop]=Cool.map(this.currentFrame,s.sf,s.ef,s.sv,s.ev),"s"!=s.prop&&"e"!=s.prop||(this.rndr[s.prop]=Math.round(this.rndr[s.prop])))}if(this.override)for(const t in this.over)this.rndr[t]=this.over[t];h.lc>=h.l&&n.needsUpdate&&!r?(n.update(this.rndr.n,this.rndr.r,this.rndr.w,this.rndr.v,this.rndr.ws),h.lc=0):n.needsUpdate&&!r&&h.lc++,this.mixedColors&&this.ctx.beginPath();for(let t=this.rndr.s;t<this.rndr.e-1;t++){const s=n.get(t),r=n.get(t+1);if("end"!==s&&"end"!==r){const t=[...s.off,...r.off];if(t.length<this.rndr.n+1)for(let s=t.length-1;s<this.rndr.n+1;s++)t.push(new Cool.Vector);const e=new Cool.Vector(r.x,r.y);e.subtract(s),e.divide(this.rndr.n),this.ctx.moveTo(this.rndr.x+s.x+t[0].x,this.rndr.y+s.y+t[0].y);for(let r=0;r<this.rndr.n;r++){const i=new Cool.Vector(s.x+e.x*r,s.y+e.y*r);this.ctx.lineTo(this.rndr.x+i.x+e.x+t[r+1].x,this.rndr.y+i.y+e.y+t[r+1].y)}this.ctx.strokeStyle!=this.rndr.c&&this.mixedColors&&(this.ctx.strokeStyle=this.rndr.c)}}this.mixedColors&&this.ctx.stroke()}}this.mixedColors||this.ctx.stroke(),this.onDraw&&this.onDraw()}load(t,s){fetch(t).then(t=>t.json()).then(t=>{this.loadData(t,s)}).catch(t=>{console.error(t)})}loadJSON(t,s){this.loadData(t,s)}loadData(t,s){this.loaded=!0;for(let s=0;s<t.d.length;s++)this.drawings[s]=t.d[s]?new Drawing(t.d[s]):null;this.layers=t.l;for(let t=0;t<this.layers.length;t++){const s=this.layers[t];s.l||(s.l=5),s.lc||(s.lc=0),this.drawings[s.d].update(s.n,s.r,s.w,s.v,s.ws)}for(const s in t.s)this.states[s]=t.s[s];this.states.default&&(this.states.default.end=this.endFrame),this.fps=t.fps,t.mc&&(this.mixedColors=t.mc),this.width=t.w,this.height=t.h,s&&s(t)}setOnLoad(t){this.loaded?t():this.onLoad=t}}
//# sourceMappingURL=src_maps/base.min.js.map
