class Drawing{constructor(t){if(this.points=[],t)for(let s=0;s<t.length;s++)this.add(t[s]);this.offset=new Cool.Vector}add(t){"end"==t||0==t?this.points.push("end"):Array.isArray(t)?this.points.push(new Cool.Vector(t)):(t.off=[],this.points.push(t))}pop(){this.points.pop()}get(t){return t<0?this.points[this.points.length-t]:this.points[t]}get length(){return this.points.length}update(t){const{segmentNum:s,jiggleRange:e,wiggleRange:i,v:r,ws:h}=t,o=(new Cool.Vector).random(r);this.offset=(new Cool.Vector).random(0,i);for(let t=0;t<this.points.length;t++)if("end"!=this.points[t]){this.points[t].off=[];for(let r=0;r<s;r++){if(i>0&&(0==r||h)){this.offset.add(o);for(const t in o)(this.offset[t]>=i||this.offset[t]<=-i)&&(o[t]*=-1)}this.points[t].off.push({x:Cool.random(-e,e)+this.offset.x,y:Cool.random(-e,e)+this.offset.y})}}}}class Layer{constructor(t,s){this.drawingIndex=t.d,this.x=t.x||0,this.y=t.y||0,this.tweens=t.t||[],this.f=t.f,this._startFrame=t.f.s,this._endFrame=t.f.e,this.drawingStartIndex=0,this.drawingEndIndex=s||-1,this.color=t.c||t.color||"#000000",this.segmentNum=t.segmentNum||t.n,this.jiggleRange=t.jiggleRange||t.r,this.wiggleRange=t.wiggleRange||t.w,this.v=t.v,this.ws=t.ws||!1,t.o&&(this.order=t.o),this.linesInterval=t.l||5,this.linesCount=0,this.isToggled=!1,this.resetTweens(),console.log(this)}update(){return this.linesCount>=this.linesInterval?(this.linesCount=0,!0):(this.linesCount++,!1)}toggle(){this.isToggled?"#00CC96"==this.color&&(this.color=this.tempColor):(this.tempColor=this.color,this.color="#00CC96"),this.isToggled=!this.isToggled}remove(){lns.anim.layers.splice(lns.anim.layers.indexOf(this),1)}addTween(t){this.tweens.push(t),t.sf<this.startFrame&&(this.startFrame=t.sf),t.ef>this.endFrame&&(this.endFrame=t.ef)}get startFrame(){return this._startFrame}set startFrame(t){this._startFrame=Math.max(0,+t),this.resetTweens()}get endFrame(){return this._endFrame}set endFrame(t){this._endFrame=Math.max(0,+t),this.resetTweens()}addIndex(t){if(!this.isInFrame(t))if(this.f.s-1==t)this.f.s-=1;else{if(this.f.e+1!=t)return new Layer({...this,f:{s:t,e:t}});this.f.e+=1}return this}removeIndex(t,s){if(this.startFrame==t&&this.endFrame==t)s();else if(this.startFrame==t)this.startFrame+=1;else{if(this.endFrame!=t){if(t>this.startFrame&&t<this.endFrame){const s=_.cloneDeep(this);return s.startFrame=t+1,s.endFrame=this.endFrame,s.resetTweens(),this.endFrame=t-1,this.resetTweens(),s}return this}this.endFrame-=1}this.resetTweens()}shiftIndex(t,s){return s||(s=-1),this.startFrame>=t&&(this.startFrame+=s),this.endFrame>=t&&(this.endFrame+=s),this.resetTweens(),this}isInFrame(t){return-1!=lns.anim.layers.indexOf(this)&&(t>=this.f.s&&t<=this.f.e)}get saveProps(){const t={n:this.segmentNum,r:this.jiggleRange,w:this.w,v:this.v,ws:this.ws,x:this.x,y:this.y,c:this.isToggled?this.tempColor:this.color,f:{s:this.startFrame,e:this.endFrame},d:this.drawingIndex};return this.tweens&&(t.t=this.tweens),this.order&&(t.o=this.order),t}get props(){const t={segmentNum:this.segmentNum,jiggleRange:this.jiggleRange,w:this.w,v:this.v,ws:this.ws,x:this.x,y:this.y,l:this.l,linesInterval:this.linesInterval,c:this.isToggled?this.tempColor:this.color};return this.order&&(t.o=this.order),t}resetTweens(){for(let t=0;t<this.tweens.length;t++){const s=this.tweens[t];s.sf<this.startFrame&&(s.sf=this.startFrame),s.ef>this.endFrame&&(s.ef=this.endFrame)}}}class LinesAnimation{constructor(t,s,e){this.ctx=t,this.isLoaded=!1,this.isPlaying=!1,this.multiColor=e||!0,this.drawings=[],this.layers=[],this.dps=s||30,this.fps=5,this.currentFrame=0,this.drawsPerFrame=Math.round(this.dps/this.fps),this.drawCount=0,this.props={off:{x:0,y:0},speed:{x:0,y:0},override:{}},this._state="default",this.states={default:{start:0,end:0}}}set fps(t){this._fps=+t,this.drawsPerFrame=Math.round(this.dps/this.fps),this.drawCount=0}get fps(){return this._fps}set frame(t){this.currentFrame=+t,this.states.default&&this.states.default.end!=this.endFrame&&(this.states.default.end=this.endFrame)}get endFrame(){return this.layers.length>0?Math.max.apply(Math,this.layers.map(t=>t.f.e)):0}set state(t){this._state!=t&&this.states[t]&&(this._state=t,this.state&&(this.frame=this.state.start))}get state(){return this.states[this._state]}get stateName(){return this._state}overrideProperty(t,s){this.props.override[t]=s}cancelOverride(){this.props.override={}}update(){this.isPlaying&&(this.drawCount==this.drawsPerFrame&&(this.currentFrame>=this.state.end?(this.currentFrame=this.state.start,this.onPlayedState&&this.onPlayedState()):this.currentFrame++,this.drawCount=0),this.drawCount++,this.onUpdate&&this.onUpdate())}draw(t,s,e){this.multiColor||this.ctx.beginPath();const i=this.layers.filter(t=>t.isInFrame(this.currentFrame)).sort((t,s)=>t.order?t.order>s.order?1:-1:1);for(let r=0;r<i.length;r++){const h=i[r],o=this.drawings[h.drawingIndex];this.props.s=h.drawingStartIndex,this.props.e=o.length;for(const t in h)this.props[t]=h[t];if(t&&(this.props.x+=t),s&&(this.props.y+=s),h.tweens)for(let t=0;t<h.tweens.length;t++){const s=h.tweens[t];s.sf<=this.currentFrame&&s.ef>=this.currentFrame&&(this.props[s.prop]=Cool.map(this.currentFrame,s.sf,s.ef,s.sv,s.ev),"s"!=s.prop&&"e"!=s.prop||(this.props[s.prop]=Math.round(this.props[s.prop])))}for(const t in this.props.override)this.props[t]=this.props.override[t];if(!e){h.update()&&o.update(this.props)}this.multiColor&&this.ctx.beginPath();for(let t=this.props.s;t<this.props.e-1;t++){const s=o.get(t),e=o.get(t+1);if("end"!==s&&"end"!==e){const t=[...s.off,...e.off];if(t.length<this.props.segmentNum+1)for(let s=t.length-1;s<this.props.segmentNum+1;s++)t.push(new Cool.Vector);0==t.length&&(console.log(this.props),console.log(t.length,this.props.segmentNum));const i=new Cool.Vector(e.x,e.y);i.subtract(s),i.divide(this.props.segmentNum),this.ctx.moveTo(this.props.x+s.x+t[0].x,this.props.y+s.y+t[0].y);for(let e=0;e<this.props.segmentNum;e++){const r=s.clone().add(i.clone().multiply(e));t[e+1]||console.log("k + 1",e+1,this.props,t,o),this.ctx.lineTo(this.props.x+r.x+i.x+t[e+1].x,this.props.y+r.y+i.y+t[e+1].y)}this.ctx.strokeStyle!=this.props.color&&this.multiColor&&(this.ctx.strokeStyle=this.props.color)}}this.multiColor&&this.ctx.stroke()}this.multiColor||this.ctx.stroke(),this.onDraw&&this.onDraw()}load(t,s){fetch(t).then(t=>t.json()).then(t=>{this.loadData(t,s)}).catch(t=>{console.error(t)})}loadJSON(t,s){this.loadData(t,s)}loadData(t,s){this.loaded=!0;for(let s=0;s<t.d.length;s++)this.drawings[s]=t.d[s]?new Drawing(t.d[s]):null;for(let s=0;s<t.l.length;s++)this.layers[s]=new Layer(t.l[s],this.drawings[t.l[s].d].length);for(let t=0;t<this.layers.length;t++){const s=this.layers[t];this.drawings[s.drawingIndex].update(s)}for(const s in t.s)this.states[s]=t.s[s];this.states.default&&(this.states.default.end=this.endFrame),this.fps=t.fps,t.mc&&(this.multiColor=t.mc),this.width=t.w,this.height=t.h,s&&s(t),this.onLoad&&this.onLoad()}setOnLoad(t){this.isLoaded?t():this.onLoad=t}}
//# sourceMappingURL=src_maps/base.min.js.map
