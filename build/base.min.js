class Drawing{constructor(t){if(this.points=[],t)for(let e=0;e<t.length;e++)this.add(t[e]);this.offset=new Cool.Vector}add(t){"end"==t||0==t?this.points.push("end"):Array.isArray(t)?this.points.push(new Cool.Vector(t)):(t.off=[],this.points.push(t))}pop(){this.points.pop()}get(t){return t<0?this.points[this.points.length-t]:this.points[t]}get length(){return this.points.length}update(t){const{segmentNum:e,jiggleRange:s,wiggleRange:i,wiggleSpeed:r,wiggleSegments:n}=t,a=(new Cool.Vector).random(r);this.offset=(new Cool.Vector).random(0,i);for(let t=0;t<this.points.length;t++)if("end"!=this.points[t]){this.points[t].off=[];for(let r=0;r<e;r++){if(i>0&&(0==r||n)){this.offset.add(a);for(const t in a)(this.offset[t]>=i||this.offset[t]<=-i)&&(a[t]*=-1)}this.points[t].off.push({x:Cool.random(-s,s)+this.offset.x,y:Cool.random(-s,s)+this.offset.y})}}}}class Layer{constructor(t,e){this.drawingIndex=t.drawingIndex,this.tweens=t.tweens||[],this.x=t.x||0,this.y=t.y||0,this._startFrame=t.startFrame,this._endFrame=t.endFrame||t.startFrame,this.drawingStartIndex=0,this.drawingEndIndex=t.drawingEndIndex||-1,this.color=t.color||"#000000",this.segmentNum=t.segmentNum,this.jiggleRange=t.jiggleRange,this.wiggleRange=t.wiggleRange,this.wiggleSpeed=t.wiggleSpeed,this.wiggleSegments=t.wiggleSegments||!1,this.breaks=t.breaks||!1,t.order&&(this.order=t.order),this.linesInterval=t.linesInterval,this.linesCount=0,this.isToggled=!1,this.resetTweens()}update(){return this.linesCount>=this.linesInterval?(this.linesCount=0,!0):(this.linesCount++,!1)}toggle(){this.isToggled?"#00CC96"==this.color&&(this.color=this.tempColor):(this.tempColor=this.color,this.color="#00CC96"),this.isToggled=!this.isToggled}addTween(t){this.tweens.push(t),t.startFrame<this.startFrame&&(this.startFrame=t.startFrame),t.endFrame>this.endFrame&&(this.endFrame=t.endFrame),"default"==lns.anim.stateName&&lns.anim.state.end<this.endFrame&&(lns.anim.state.end=this.endFrame)}get startFrame(){return this._startFrame}set startFrame(t){this._startFrame=Math.max(0,+t),this.resetTweens()}get endFrame(){return this._endFrame}set endFrame(t){this._endFrame=Math.max(0,+t),this.resetTweens()}resetTweens(){for(let t=0;t<this.tweens.length;t++){const e=this.tweens[t];e.startFrame<this.startFrame&&(e.startFrame=this.startFrame),e.endFrame>this.endFrame&&(e.endFrame=this.endFrame)}}addIndex(t){if(!this.isInFrame(t))if(this.f.s-1==t)this.f.s-=1;else{if(this.f.e+1!=t)return new Layer({...this,f:{s:t,e:t}});this.f.e+=1}return this}removeIndex(t,e){if(this.startFrame==t&&this.endFrame==t)e();else if(this.startFrame==t)this.startFrame+=1;else{if(this.endFrame!=t){if(t>this.startFrame&&t<this.endFrame){const e=_.cloneDeep(this);return e.startFrame=t+1,e.endFrame=this.endFrame,e.resetTweens(),this.endFrame=t-1,this.resetTweens(),e}return this}this.endFrame-=1}this.resetTweens()}shiftIndex(t,e){return e||(e=-1),this.startFrame>=t&&(this.startFrame+=e),this.endFrame>=t&&(this.endFrame+=e),this.resetTweens(),this}isInFrame(t){return t>=this.startFrame&&t<=this.endFrame}get saveProps(){const t={n:this.segmentNum,r:this.jiggleRange,w:this.wiggleRange,v:this.wiggleSpeed,ws:this.wiggleSegments,c:this.isToggled?this.tempColor:this.color,f:[this.startFrame,this.endFrame],d:this.drawingIndex};return this.x&&(t.x=x),this.y&&(t.y=y),this.tweens&&(t.t=this.tweens.map(t=>[t.prop,t.startFrame,t.endFrame,t.startValue,t.endValue])),this.order&&(t.o=this.order),t}get drawProps(){const t={segmentNum:this.segmentNum,jiggleRange:this.jiggleRange,wiggleRange:this.wiggleRange,wiggleSpeed:this.wiggleSpeed,wiggleSegments:this.wiggleSegments,x:this.x,y:this.y,linesCount:this.linesCount,linesInterval:this.linesInterval,color:this.color,startIndex:this.drawingStartIndex,endIndex:this.drawingEndIndex,tweens:this.tweens};return this.order&&(t.o=this.order),t}get editProps(){return{segmentNum:this.segmentNum,jiggleRange:this.jiggleRange,wiggleRange:this.wiggleRange,wiggleSpeed:this.wiggleSpeed,wiggleSegments:this.wiggleSegments,linesInterval:this.linesInterval,breaks:this.breaks,color:this.color}}get tweenProps(){return{segmentNum:this.segmentNum,jiggleRange:this.jiggleRange,wiggleRange:this.wiggleRange,wiggleSpeed:this.wiggleSpeed,wiggleSegments:this.wiggleSegments,linesInterval:this.linesInterval,startIndex:this.drawingStartIndex,endIndex:this.drawingEndIndex}}}class LinesAnimation{constructor(t,e,s){this.ctx=t,this.isLoaded=!1,this.isPlaying=!1,this.multiColor=s||!0,this.drawings=[],this.layers=[],this.dps=e||30,this.fps=5,this.currentFrame=0,this.drawsPerFrame=Math.round(this.dps/this.fps),this.drawCount=0,this.override={},this._state="default",this.states={default:{start:0,end:0}}}set fps(t){this._fps=+t,this.drawsPerFrame=Math.round(this.dps/this.fps),this.drawCount=0}get fps(){return this._fps}set frame(t){this.currentFrame=+t,this.states.default&&this.states.default.end!=this.endFrame&&(this.states.default.end=this.endFrame)}get endFrame(){const t=this.layers.map(t=>t.endFrame);return Math.max.apply(Math,t)}set state(t){this._state!=t&&this.states[t]&&(this._state=t,this.state&&(this.frame=this.state.start))}get state(){return this.states[this._state]}get stateName(){return this._state}overrideProperty(t,e){this.override[t]=e}cancelOverride(){this.override={}}update(){this.isPlaying&&(this.drawCount==this.drawsPerFrame&&(this.currentFrame>=this.state.end?(this.currentFrame=this.state.start,this.onPlayedState&&this.onPlayedState()):this.currentFrame++,this.drawCount=0),this.drawCount++,this.onUpdate&&this.onUpdate())}draw(t,e,s){this.multiColor||this.ctx.beginPath();const i=this.layers.filter(t=>t.isInFrame(this.currentFrame)).sort((t,e)=>t.order?t.order>e.order?1:-1:1);for(let r=0;r<i.length;r++){const n=i[r],a=this.drawings[n.drawingIndex],h=n.drawProps;if(t&&(h.x+=t),e&&(h.y+=e),h.tweens)for(let t=0;t<h.tweens.length;t++){const e=h.tweens[t];e.startFrame<=this.currentFrame&&e.endFrame>=this.currentFrame&&(h[e.prop]=Cool.map(this.currentFrame,e.startFrame,e.endFrame,e.startValue,e.endValue),"startIndex"!=e.prop&&"endIndex"!=e.prop||(h[e.prop]=Math.round(h[e.prop])))}for(const t in this.override)h[t]=this.override[t];if(!s){n.update()&&a.update(h)}this.multiColor&&this.ctx.beginPath();const o=h.endIndex>0?h.endIndex:a.length;for(let t=h.startIndex;t<o-1;t++){const e=a.get(t),s=a.get(t+1);if("end"!==e&&"end"!==s){const t=[...e.off,...s.off];if(t.length<h.segmentNum+1)for(let e=t.length-1;e<h.segmentNum+1;e++)t.push(new Cool.Vector);const i=new Cool.Vector(s.x,s.y);i.subtract(e),i.divide(h.segmentNum),this.ctx.moveTo(h.x+e.x+t[0].x,h.y+e.y+t[0].y);for(let s=0;s<h.segmentNum;s++){const r=e.clone().add(i.clone().multiply(s));t[s+1]||console.log("k + 1",s+1,h,t,a);const n=h.breaks?s:s+1;this.ctx.lineTo(h.x+r.x+i.x+t[n].x,h.y+r.y+i.y+t[n].y)}this.ctx.strokeStyle!=h.color&&this.multiColor&&(this.ctx.strokeStyle=h.color)}}this.multiColor&&this.ctx.stroke()}this.multiColor||this.ctx.stroke(),this.onDraw&&this.onDraw()}load(t,e){fetch(t).then(t=>t.json()).then(t=>{this.loadData(t,e)}).catch(t=>{console.error(t)})}loadJSON(t,e){this.loadData(t,e)}loadData(t,e){this.loaded=!0;for(let e=0;e<t.d.length;e++)this.drawings[e]=t.d[e]?new Drawing(t.d[e]):null;for(let e=0;e<t.l.length;e++){const s=this.loadParams(t.l[e]);s.drawingEndIndex=this.drawings[s.drawingIndex].length;const i=new Layer(s);this.layers[e]=i,this.drawings[i.drawingIndex].update(i)}for(const e in t.s)this.states[e]=t.s[e];this.states.default&&(this.states.default.end=this.endFrame),this.fps=t.fps,t.mc&&(this.multiColor=t.mc),this.width=t.w,this.height=t.h,e&&e(t),this.onLoad&&this.onLoad()}loadParams(t){const e={drawingIndex:t.d,tweens:t.t.map(t=>({prop:t[0],startFrame:t[1],endFrame:t[2],startValue:t[3],endValue:t[4]})),startFrame:t.f[0],endFrame:t.f[1],x:t.x||0,y:t.y||0,color:t.c,segmentNum:t.n,jiggleRange:t.r,wiggleRange:t.w,wiggleSpeed:t.v,wiggleSegments:t.ws,breaks:t.b||!1,linesInterval:t.l||5};return t.o&&(e.order=t.o),e}setOnLoad(t){this.isLoaded?t():this.onLoad=t}}
//# sourceMappingURL=src_maps/base.min.js.map
