!function(){"use strict";const{Renderer:t,Loader:i}=window.Lines;window.LinesEngine={},window.LinesEngine.Game=class{constructor(s){window.GAME=this,this.renderer=new t({dps:60,clearBg:!1,...s}),this.drawCount=0,this.drawInterval=Math.round(60/(s.dps||30)),this.drawTime=1e3/(s.dps||30);let e=.01;if(s.testPerformance){const t=[];console.groupCollapsed("perf test");for(let i=0;i<5;i++)t.push(Cool.testPerformance());e=t.reduce(((t,i)=>t+i))/t.length,console.log("perf avg",e),console.groupEnd("perf test")}this.width=s.width,this.height=s.height,this.halfWidth=Math.round(s.width/2),this.halfHeight=Math.round(s.height/2),this.debug=s.debug||!1,this.suspendOnTimeOver=s.suspend||!1,this.suspend=!1,this.editorSuspend=!1,this.loader=new i({relativeLoadPath:s.relativeLoadPath,saveAnimationData:s.saveAnimationData||s.saveJsons||!1}),this.anims={},this.bounds=s.bounds||{top:0,bottom:0,left:0,right:0},this.scenes=new l(s.scenes,o),this.useMouseEvents=!s.events||s.events.includes("mouse"),this.useKeyboardEvents=!s.events||s.events.includes("keyboard"),this.useTouchEvents=!!s.events&&s.events.includes("touch"),this.view={width:this.width,height:this.height},this.zoom=s.zoom||1;let h=s.isEditor?this.renderer.getProps().dpr:1;this.view.width=Math.round(this.width/this.zoom*h),this.view.height=Math.round(this.height/this.zoom*h),this.view.halfWidth=this.view.width/2,this.view.halfHeight=this.view.height/2;let n=!1;(e>.1||s.lowPerformance)&&(n=!!s.ignoreAlerts||confirm("Low performance detected, click Okay to use low graphics quality, cancel to continue with high graphics quality.")),n?this.zoom&&(this.width=Math.round(this.width/this.zoom),this.height=Math.round(this.height/this.zoom),this.halfWidth=Math.round(this.width/2),this.halfHeight=Math.round(this.height/2),this.renderer.setWidth(this.width),this.renderer.setHeight(this.height),this.renderer.setScale(1),s.smallCanvas?(this.renderer.canvas.style.width=this.width+"px",this.renderer.canvas.style.height=this.height+"px"):s.useSVGFilterOnLow&&!navigator.userAgent.includes("Firefox")&&(s.svgFilter=!0)):s.zoom&&this.renderer.setScale(h*s.zoom),s.stats&&(this.stats=new Stats,document.body.appendChild(this.stats.dom),this.stats.dom.style.left="auto",this.stats.dom.style.right="0px",this.drawStats=new Stats,document.body.appendChild(this.drawStats.dom),this.drawStats.dom.style.left="auto",this.drawStats.dom.style.right="0px",this.drawStats.dom.style.top="48px")}setView(t,i){this.renderer.setWidth(t),this.renderer.setHeight(i),this.width=t,this.height=i,this.halfWidth=Math.round(t/2),this.halfHeight=Math.round(i/2),this.view.width=Math.round(this.width/this.zoom),this.view.height=Math.round(this.height/this.zoom),this.view.halfWidth=this.view.width/2,this.view.halfHeight=this.view.height/2,this.renderer.reset()}load(t,i,s){this.loader.load(t,i,(t=>{for(const i in t){this.anims[i]={};for(const s in t[i])this.anims[i][s]=new r,this.anims[i][s].loadData(t[i][s].json)}this._start()}))}_start(){this.drawTime=performance.now(),this.renderer.start(),this.start&&this.start(),this.update||(this.noUpdate=!0),this.renderer.addCallback((t=>{this._update(t)})),this.stats&&(this.renderer.addCallback((()=>{this.stats.begin()}),"pre"),this.renderer.addCallback((()=>{this.stats.end()}),"pre")),this.useMouseEvents&&this.startMouseEvents(),this.useKeyboardEvents&&this.startKeyboardEvents(),this.useTouchEvents&&this.startTouchEvents(),this.sizeCanvas&&window.addEventListener("resize",this.sizeCanvas,!1)}_draw(){this.stats&&this.drawStats.begin(),this.renderer.ctx.clearRect(0,0,this.width,this.height),this.draw(),this.stats&&this.drawStats.end()}_update(t){this.pauseGame||(this.noUpdate||this.update(t),t>this.drawTime+this.drawInterval&&this._draw(time),0===this.drawCount&&this._draw(),this.drawCount=(this.drawCount+1)%this.drawInterval,this.suspendOnTimeOver&&!this.editorSuspend&&(!this.suspend&&t>1.5*this.drawTime?this.suspend=!0:this.suspend&&(this.suspend=!1)))}setBounds(t,i){this.bounds[t]=Math.round(i)}updateBounds(t){t.y<this.bounds.top&&(this.bounds.top=Math.round(t.y)),t.y>this.bounds.bottom&&(this.bounds.bottom=Math.round(t.y+this.height)),t.x>this.bounds.right&&(this.bounds.right=Math.round(t.x+this.width/2)),t.x<this.bounds.left&&(this.bounds.left=Math.round(t.x-this.width/2))}startMouseEvents(){let t,i=!1,{canvas:s}=this.renderer;s.addEventListener("click",(t=>{t.preventDefault(),this.mouseClicked&&this.mouseClicked(t.offsetX/this.zoom,t.offsetY/this.zoom)}),!1),s.addEventListener("mousedown",(s=>{s.preventDefault(),this.mouseDown&&this.mouseDown(s.offsetX/this.zoom,s.offsetY/this.zoom,s.which,s.shiftKey),this.startDrag&&(t=startDrag(s.offsetX,s.offsetY),t&&(i=!0))}),!1),s.addEventListener("mouseup",(t=>{t.preventDefault(),this.mouseUp&&this.mouseUp(t.offsetX/this.zoom,t.offsetY/this.zoom,t.which),i&&(i=!1)}),!1),s.addEventListener("mousemove",(s=>{this.mouseMoved&&this.mouseMoved(s.offsetX/this.zoom,s.offsetY/this.zoom,s.which),i&&drag(s.offsetX/this.zoom,s.offsetY/this.zoom,t)}),!1)}startTouchEvents(){this.canvas.addEventListener("touchstart",(t=>{t.preventDefault(),this.touchStart&&this.touchStart(t)}),!1),this.canvas.addEventListener("touchmove",(t=>{t.preventDefault(),this.touchMove&&this.touchMove(t)}),!1),this.canvas.addEventListener("touchend",(t=>{t.preventDefault(),this.touchEnd&&this.touchEnd(t)}),!1)}startKeyboardEvents(){document.addEventListener("keydown",(t=>{this.keyDown&&"INPUT"!==t.target.tagName&&this.keyDown(Cool.keys[t.which])})),document.addEventListener("keyup",(t=>{this.keyUp&&"INPUT"!==t.target.tagName&&this.keyUp(Cool.keys[t.which])}))}};class s{constructor(t,i,s,e){this.position=[Math.round(t)||0,Math.round(i)||0],this.size=[0,0],this.halfWidth=0,this.halfHeight=0,this.debug=!1,this.debugColor="#00ffbb",this.isActive=!0,this.center=!1,s&&this.addAnimation(s,e)}get x(){return this.xy[0]}get y(){return this.xy[1]}get width(){return this.size[0]}get height(){return this.size[1]}get xy(){return this.center?[this.position[0]-this.halfWidth,this.position[1]-this.halfHeight]:this.position}addAnimation(t,i){this.animation=t,this.size=[this.animation.width,this.animation.height],this.halfWidth=Math.round(this.animation.width/2),this.halfHeight=Math.round(this.animation.height/2),i&&i(t)}drawDebug(){GAME.ctx.lineWidth=1,GAME.ctx.beginPath(),GAME.ctx.rect(this.x,this.y,this.width,this.height);const t=GAME.ctx.strokeStyle;GAME.ctx.strokeStyle=this.debugColor,GAME.ctx.stroke(),GAME.ctx.strokeStyle=t,this.label&&GAME.ctx.fillText(this.label,this.position.x,this.position.y),1!==GAME.lineWidth&&(GAME.ctx.lineWidth=GAME.lineWidth)}display(t){let i=!1;i=void 0!==t?t:this.isActive&&this.isOnScreen(),i&&(this.debug&&this.drawDebug(),this.animation&&(this.animation.update(),this.isActive&&this.animation.draw(this.x,this.y,GAME.suspend))),this.displayFunc&&this.displayFunc()}isOnScreen(){return this.x+this.width>0&&this.y+this.height>0&&this.x<GAME.view.width&&this.y<GAME.view.height}}window.LinesEngine.Sprite=s;class e extends s{constructor(t,i,s,e){super(t,i),this.collider=[0,0,0,0],this.mouseOver=!1,this.waitToGoOut=!1,this.clickStarted=!1,s&&this.addAnimation(s,e)}addAnimation(t,i){super.addAnimation(t,i),this.collider[2]=this.animation.width,this.collider[3]=this.animation.height}setCollider(t,i,s,e){this.collider=[t,i,s,e]}drawDebug(){GAME.ctx.lineWidth=1,GAME.ctx.beginPath(),GAME.ctx.rect(this.colliderPosition[0],this.colliderPosition[1],this.collider[2],this.collider[3]);const t=GAME.ctx.strokeStyle;GAME.ctx.strokeStyle=this.debugColor,GAME.ctx.stroke(),GAME.ctx.strokeStyle=t,1!==GAME.lineWidth&&(GAME.ctx.lineWidth=GAME.lineWidth)}get colliderPosition(){return[this.x+this.collider[0],this.y+this.collider[1]]}collide(t,i){return!!(this.isActive&&t.isActive&&this.colliderPosition[0]<t.colliderPosition[0]+t.collider[2]&&this.colliderPosition[0]+this.collider[2]>t.colliderPosition[0]&&this.colliderPosition[1]<t.colliderPosition[1]+t.collider[3]&&this.colliderPosition[1]+this.collider[3]>t.colliderPosition[1])&&(i&&i(this),!0)}tap(t,i){return t>this.colliderPosition[0]&&t<this.colliderPosition[0]+this.collider[2]&&i>this.colliderPosition[1]&&i<this.colliderPosition[1]+this.collider[3]}outside(t){var i=this.position.copy(),s=this.collider.position.copy();i.add(s),i.add(this.velocity);var e=this.collider.size.copy();return i.x<t.position.x+t.collider.position.x||i.x+e.x>t.position.x+t.collider.position.x+t.collider.size.x||i.y<t.position.y+t.collider.position.y||i.y+e.y>t.position.y+t.collider.position.y+t.collider.size.y}over(t,i){return!(!this.isActive||!this.tap(t,i)||this.mouseOver||this.waitToGoOut)&&(this.mouseOver=!0,this.onOver&&this.onOver(),!0)}out(t,i){return!(!this.isActive||this.tap(t,i)||!this.mouseOver&&!this.waitToGoOut)&&(this.clickStarted=!1,this.waitToGoOut=!1,this.mouseOver=!1,this.onOut&&this.onOut(),!0)}down(t,i){return!(!this.isActive||!this.tap(t,i))&&(this.clickStarted=!0,this.waitToGoOut=!0,this.onDown&&this.onDown(),!0)}up(t,i){return!!(this.isActive&&this.tap(t,i)&&this.clickStarted)&&(this.mouseOver=!1,this.onUp&&this.onUp(),this.onClick&&this.onClick(t,i),this.func&&this.func(),!0)}}class h extends e{constructor(t,i){let s=t.x,e=t.y;s%1!=0&&(s=Math.round(GAME.view.width*s)),s<0&&(s=Math.round(GAME.view.width+s)),e%1!=0&&(e=Math.round(GAME.view.height*e)),e<0&&(e=Math.round(GAME.view.height+e)),s=Math.round(s),e=Math.round(e),super(s,e),this.debug=i,this.center=void 0===t.center||t.center,t.hidden&&(this.isActive=!1),t.animation&&(this.addAnimation(t.animation),this.animation.isPlaying=!0),t.states&&(this.animation.states=t.states,this.animation.state="idle"),t.isButton&&(this.animation.states={idle:{start:0,end:0},over:{start:1,end:1},down:{start:2,end:2}},this.onOver=function(){this.animation.state="over"},this.onOut=function(){this.animation.state="idle"},this.onDown=function(){this.animation.state="down"},this.onUp=function(){this.animation.state="over"},this.animation.state="idle"),this.scenes=t.scenes,t.func&&(this.func=window[t.func]),t.callback&&(this.callback=t.callback),t.onClick&&(this.onClick=t.onClick),t.onOver&&(this.onOver=t.onOver),t.onOut&&(this.onOut=t.onOut),t.onUp&&(this.onUp=t.onUp),t.onDown&&(this.onDown=t.onDown)}}class o{constructor(){this.displaySprites=new c,this.updateSprites=new c,this.uiSprites=new c}add(t){this.displaySprites.add(t),this.updateSprites.add(t),this.uiSprites.add(t)}remove(t,i){const s=i?[i]:["display","update","ui"];for(let i=0;i<s.length;i++)this[`${s[i]}Sprites`].remove(t)}addSprite(t){this.displaySprites.add(t),this.updateSprites.add(t)}addUI(t){this.displaySprites.add(t),this.uiSprites.add(t)}addToDisplay(t){this.displaySprites.add(t)}addToUpdate(t){this.updateSprites.add(t)}addToUI(t){this.uiSprites.add(t)}display(t){this.displaySprites.all((i=>{i.display||console.log(i),i.display(t)}))}update(t){this.updateSprites.all((i=>{i.update(t)}))}mouseMoved(t,i){this.uiSprites.all((s=>{s.over||console.log(s),s.over(t,i),s.out(t,i)}))}mouseDown(t,i){this.uiSprites.all((s=>{s.down(t,i)}))}mouseUp(t,i){this.uiSprites.all((s=>{s.up(t,i)}))}}class n extends h{constructor(t,i){super(t,i),this.mouseOver=!1,this.waitToGoOut=!1,this.clickStarted=!1,t.onOver&&(this.onOver=t.onOver),t.onOut&&(this.onOut=t.onOut),t.onDown&&(this.onDown=t.onDown),t.onClick&&(this.onClick=t.onClick)}over(t,i){const s=super.over(t,i);return s&&(this.animation.state="over"),s}out(t,i){const s=super.out(t,i);return s&&(this.animation.state="idle"),s}down(t,i){const s=super.down(t,i);return s&&(this.animation.state="active"),s}up(t,i){const s=super.up(t,i);return s&&(this.animation.state="idle"),s}}window.LinesEngine.Button=n;const{Animation:a}=window.Lines;class r extends a{constructor(t){const{dps:i,multiColor:s}=GAME.renderer.getProps();super(GAME.renderer.ctx,i,s),this.debug=t,this.loop=!0,this.randomFrames=!1,this.prevFrame=0,this.frames=[]}update(){if(this.isPlaying){if(this.drawCount==this.drawsPerFrame){if(this.randomFrames){for(;this.prevFrame===this.currentFrame;)this.currentFrame=Cool.randomInt(this.state.start,this.state.end);this.prevFrame=this.currentFrame}else this.currentFrame>=this.state.end?(this.currentFrame=this.loop?this.state.start:this.state.end,this.onPlayedOnce&&(this.onPlayedOnce(),this.onPlayedOnce=void 0),this.onPlayedState&&this.onPlayedState()):this.currentFrame++;this.drawCount=0}this.drawCount++,this.onUpdate&&this.onUpdate()}}createNewState(t,i,s){this.states[t]||(this.states[t]={start:i,end:s}),this.state=t}playStateCheck(){this.state.start!=this.state.end&&(this.isPlaying=!0)}set state(t){this._state!==t&&this.states[t]&&(this._state=t,this.state&&(this.frame=this.state.start),this.isPlaying||"default"===t||(this.isPlaying=!0))}get state(){return this.states[this._state]}playOnce(t){this.isPlaying||(this.isPlaying=!0),this.frame=this.state.start,this.onPlayedOnce=t}loadData(t,i){super.loadData(t,i),this.setFrames()}setFrames(){for(let t=0,i=this.layers.length;t<i;t++){const i=this.layers[t];for(let s=i.startFrame;s<=i.endFrame;s++)this.frames[s]||(this.frames[s]=[]),this.frames[s].push(t)}}getLayers(){const t=this.frames[this.currentFrame],i=[];for(let s=0;s<t.length;s++)i.push(this.layers[t[s]]);return i}}window.LinesEngine.GameAnim=r;class d{constructor(t,i){for(let s=0;s<t.length;s++)this[t[s]]=new i;this._current=t[0],this.names=t}set current(t){this._current=t}get current(){return this[this._current]}get currentName(){return this._current}get list(){return this.names}}class l extends d{add(t,i,s){"string"==typeof i&&(i=[i]);for(let e=0;e<i.length;e++)"display"==s?this[i[e]].addToDisplay(t):"ui"==s?this[i[e]].addUI(t):this[i[e]].addSprite(t)}addToDisplay(t,i){this.add(t,i,"display")}addUI(t,i){this.add(t,i,"ui")}}class c{constructor(t){this.sprites=t?[...t]:[]}get length(){return this.sprites.length}includes(t){return this.sprites.includes(t)}sprite(t){return this.sprites[t]}remove(t){this.sprites.splice(this.sprites.indexOf(t),1)}clear(){this.sprites=[]}add(t){this.sprites.includes(t)||this.sprites.push(t)}all(t){for(let i=0;i<this.sprites.length;i++)t(this.sprites[i],i)}update(){this.all((t=>{t.update()}))}display(){this.all((t=>{t.display()}))}over(t,i){this.all((s=>{s.over(t,i)}))}out(t,i){this.all((s=>{s.out(t,i)}))}down(t,i){this.all((s=>{s.down(t,i)}))}up(t,i){this.all((s=>{s.up(t,i)}))}}LinesEngine.TextButton=class extends h{constructor(t){super(t),this.center=!1,this.text=new u(t),this.setCollider()}setMsg(t){this.text.setMsg(t),this.text.wrap=t.length,this.setCollider()}setCollider(){this.collider[0]=0,this.collider[1]=0,this.collider[2]=(this.text.wrap<this.text.msg.length?this.text.wrap:this.text.msg.length)*this.text.track,this.collider[3]=(this.text.breaks.length+1)*this.text.letters.height}display(){super.display(),this.isActive&&this.text.display()}setPosition(t,i){this.position.x=t,this.position.y=i,this.text.setPosition(t,i)}};class u{constructor(t){if(this.x=Math.round(t.x||0),this.y=Math.round(t.y||0),this.lead=t.lead||35,this.track=t.track||18,this.wrap=t.wrap||wrap,this.isActive=!0,this.letters=t.letters,this.breaks=[],this.countForward=t.countForward||!1,this.countBackward=t.countBackward||!1,this.count=0,this.end=0,this.delay=0,this.countCount=.5,this.endCount=.5,this.endDelay=GAME.dps||10,this.hover=!1,this.clickStarted=!1,this.setMsg(t.msg),!t.letters.states[0]){const i=t.letterIndexString||"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,:?-+'&$;\"!";for(let s=0;s<i.length;s++)t.letters.createNewState(i[s],s,s)}}setPosition(t,i){this.x=t,this.y=i}center(){this.x-=this.track*Math.min(this.msg.length,this.wrap)/2}setMsg(t){this.msg=t.replace(/\s+$/,""),this.setBreaks();let i=this.breaks.map(((t,i)=>i>0?t-this.breaks[i]:t));this.width=this.breaks.length<=0?this.track*this.msg.length:this.track*Math.max(0,...i),this.height=(this.breaks.length+1)*this.lead,this.reset()}setBreaks(){let t=!1,i=0,s=!1;this.breaks=[];for(let e=1;e<this.msg.length;e++)if(s=!1,!this.msg[e].match(/[\n\r]/g)||s)if(e%this.wrap!==i||t)" "===this.msg[e]&&t&&(this.breaks.push(e),i=e%this.wrap,t=!1,s=!0);else{let i=Math.round(this.wrap/2),h=this.msg.substring(e,e+i);if(" "===this.msg[e])this.breaks.push(e),s=!0;else if(!h.match(/[\n\r\s]/g)&&h.length>=i){for(let t=e-1;t>=i;t--)if(" "===this.msg[t]){this.breaks.push(t),s=!0;break}}else t=!0}else this.breaks.push(e),i=e%this.wrap,t=!1}reset(){this.end=0,this.count=0,this.delay=0}display(t,i,s){if(!this.isActive)return!0;t=t||this.countForward,i=i||this.countBackward,s=s||this.yAbove;const e=t?Math.floor(this.count):this.msg.length,h=i?this.end:0;let o=this.x,n=this.y-(s?(this.breaks.length+1)*this.lead:0);for(let t=0;t<e;t++){var a=this.msg[t];" "===a||"_"===a||t<h?o+=this.track:"\n"===a||"\r"===a||(this.letters.state=a,this.letters.draw(o,n),o+=this.track),-1!==this.breaks.indexOf(t)&&(n+=this.lead,o=this.x)}if(this.count<this.msg.length&&(this.count+=this.countCount),this.count>=this.msg.length&&(this.delay<this.endDelay?this.delay+=1:this.end+=this.endCount),i){if(this.end>=this.msg.length)return this.reset(),this.onDialogEnd&&this.onDialogEnd(),!0}else if(this.end>=this.endDelay)return this.reset(),this.onDialogEnd&&this.onDialogEnd(),!0}}window.LinesEngine.TextSprite=u;window.LinesEngine.Texture=class{constructor(t,i){this.locations=t.locations||[],this.frame=t.frame||"index",this.debug=i,this.center=t.center||!1,this.offset=[0,0],t.animation&&this.addAnimation(t.animation),t.locations&&t.animation&&this.addLocations()}addAnimation(t){this.animation=t,this.halfWidth=Math.round(t.width/2),this.halfHeight=Math.round(t.height/2)}addLocation(t,i,s){const e=[t,i];if(void 0!==s)this.animation.createNewState(`f-${s}`,s,s),e.i=s;else if("randomIndex"==this.frame){let t=Cool.randomInt(0,this.animation.endFrame);this.animation.createNewState(`f-${t}`,t,t),e.i=t}this.locations.push(e)}addLocations(t){t&&this.locations.push(...t);for(let t=0;t<this.locations.length;t++)if("index"===this.frame)this.locations[t].i=t,this.animation.createNewState(`f-${t}`,t,t);else if("random"===this.frame)this.animation.randomFrames=!0;else if("randomIndex"===this.frame){let i=Cool.randomInt(0,this.animation.endFrame);this.locations[t].i=i,this.animation.createNewState(`f-${i}`,i,i)}}display(){for(let t=0;t<this.locations.length;t++){let i=this.locations[t][0]+this.offset[0],s=this.locations[t][1]+this.offset[1];this.center&&(i-=this.halfWidth,s-=this.halfHeight),i+this.animation.width>0&&i<GAME.view.width&&s+this.animation.height>0&&s<GAME.view.height&&(void 0!==this.locations[t].i&&(this.animation.state=`f-${this.locations[t].i}`),this.animation.draw(i,s,GAME.suspend))}}isOnScreen(){let t=[];for(let i=0;i<this.locations.length;i++){let s=this.locations[i][0]+this.offset[0],e=this.locations[i][1]+this.offset[1];this.center&&(s-=this.halfWidth,e-=this.halfHeight),t.push(s+this.animation.width>0&&s<GAME.view.width&&e+this.animation.height>0&&e<GAME.view.height)}return t}update(t){this.offset[0]=t[0],this.offset[1]=t[1]}}}();
//# sourceMappingURL=src_maps/game.min.js.map
